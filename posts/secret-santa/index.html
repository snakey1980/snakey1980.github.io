<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Everything I never knew about Secret Santa&hellip;
Names in a hat The first time I played Secret Santa we assigned givers/receivers like this:
 Players put their name in a hat Players take turn to shake the hat and pick a name out at random. If you pull your own name, put it back and pull again.  So when I decided to program it this is how I tried to do it.'>

<meta property='og:title' content='Secret Santa • snakey1980&#39;s GitHub Pages'>
<meta property='og:description' content='Everything I never knew about Secret Santa&hellip;
Names in a hat The first time I played Secret Santa we assigned givers/receivers like this:
 Players put their name in a hat Players take turn to shake the hat and pick a name out at random. If you pull your own name, put it back and pull again.  So when I decided to program it this is how I tried to do it.'>
<meta property='og:url' content='http://snakey1980.github.io/posts/secret-santa/'>
<meta property='og:site_name' content='snakey1980&#39;s GitHub Pages'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2017-11-13T19:49:44-05:00'/><meta property='article:modified_time' content='2017-11-13T19:49:44-05:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.30.2" />

  <title>Secret Santa • snakey1980&#39;s GitHub Pages</title>
  <link rel='canonical' href='http://snakey1980.github.io/posts/secret-santa/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Ubuntu:400,400i,700&subset=latin'>
<link rel='stylesheet' href='/assets/css/main.77da63e1.css'>
</head>


<body class='page type-posts'>
  <div class='site'>

    <a class='screen-reader' href='#main'>Skip to Content</a>

    <header id='header' class='header-container'>
      <div class='header site-header'>
        <nav id='main-menu' class='main-menu-container' aria-label='Main Menu'>
  <ul class='main-menu'>
  
  </ul>
</nav>

        <div class='header-info'>
          
          <p class='site-title title'>snakey1980&#39;s GitHub Pages</p>
          
          <p class='site-description subtitle'></p>
        </div>
      </div>
    </header>


<main id='main' class='main'>
  <article lang='en' class='entry'>
    <header class='header-container'>
  <div class='header entry-header'>
    <div class='header-info'>
      <h1 class='title'>Secret Santa</h1>
      

    </div>
    
<div class='meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader'>Posted on </span>
  <time class='date' datetime='2017-11-13T19:49:44-05:00'>2017, Nov 13</time>
</span>

  
  

</div>


  </div>
</header>

    
    

    <div class='entry-content'>
  

<p>Everything I never knew about Secret Santa&hellip;</p>

<h4 id="names-in-a-hat">Names in a hat</h4>

<p>The first time I played Secret Santa we assigned givers/receivers like this:</p>

<ol>
<li>Players put their name in a hat</li>
<li>Players take turn to shake the hat and pick a name out at random.  If you pull your own name, put it back and pull again.</li>
</ol>

<p>So when I decided to program it this is how I tried to do it.  Here we use plain integers as the players:</p>

<pre><code>fun draw(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n).toSet()
    val pot = players.toMutableList()
    Collections.shuffle(pot)
    val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
    players.forEach {
        while (pot[0] == it) {
            Collections.shuffle(pot)
        }
        result.add(Pair(it, pot.removeAt(0)))
    }
    return result
}
</code></pre>

<p>On a first try it seems to work:</p>

<pre><code>println(SecretSanta().draw(4))
// printed [(1, 4), (2, 1), (3, 2), (4, 3)]
</code></pre>

<p>but try it a few times and, on some runs, it will never finish.  It&rsquo;s not hard to see why &ndash; it&rsquo;s possible that when number 4 comes to choose, it finds only itself in the pot and reshuffles forever.</p>

<p>This could happen in a real names-in-a-hat situation too.  Has it ever happened to you?  When it does, there&rsquo;s nothing to be done but to put all the names back in and try again, so that&rsquo;s what I tried next:</p>

<pre><code>fun draw2(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n).toSet()
    class BadPotException : RuntimeException()
    while (true) {
        val pot = players.toMutableList()
        Collections.shuffle(pot)
        try {
            val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
            players.forEach {
                if (pot.size == 1 &amp;&amp; pot[0] == it) {
                    throw BadPotException()
                }
                while (pot[0] == it) {
                    Collections.shuffle(pot)
                }
                result.add(Pair(it, pot.removeAt(0)))
            }
            return result
        }
        catch (e: BadPotException) {
            // ok, try again
        }
    }
}
</code></pre>

<p>This always seems to stop, so we are doing slightly better:</p>

<pre><code>(1..100_000).forEach { SecretSanta().draw2(4) }
</code></pre>

<p>With 4 players, there aren&rsquo;t many valid assignments, just these 9:</p>

<pre><code>[(1, 2), (2, 1), (3, 4), (4, 3)]
[(1, 2), (2, 3), (3, 4), (4, 1)]
[(1, 2), (2, 4), (3, 1), (4, 3)]
[(1, 3), (2, 1), (3, 4), (4, 2)]
[(1, 3), (2, 4), (3, 1), (4, 2)]
[(1, 3), (2, 4), (3, 2), (4, 1)]
[(1, 4), (2, 1), (3, 2), (4, 3)]
[(1, 4), (2, 3), (3, 1), (4, 2)]
[(1, 4), (2, 3), (3, 2), (4, 1)]
</code></pre>

<p>A good test would be to see if our procedure returns each of the nine, and that it returns each one one ninth of the time:</p>

<pre><code>val patterns = mutableMapOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;, Int&gt;()
(1..100_000).forEach {
    val pattern = SecretSanta().draw2(4)
    patterns[pattern] = patterns.getOrDefault(pattern, 0) + 1
}
patterns.entries.sortedByDescending { it.value }.forEach { println(it) }
</code></pre>

<p>We run it 100,000 times and would expect each pattern to occur around 11,111 times.  But:</p>

<pre><code>[(1, 4), (2, 1), (3, 2), (4, 3)]=19241
[(1, 2), (2, 4), (3, 1), (4, 3)]=13004
[(1, 2), (2, 1), (3, 4), (4, 3)]=12943
[(1, 3), (2, 4), (3, 2), (4, 1)]=9775
[(1, 4), (2, 3), (3, 1), (4, 2)]=9720
[(1, 4), (2, 3), (3, 2), (4, 1)]=9685
[(1, 3), (2, 4), (3, 1), (4, 2)]=9591
[(1, 3), (2, 1), (3, 4), (4, 2)]=9532
[(1, 2), (2, 3), (3, 4), (4, 1)]=6509
</code></pre>

<p>The algorithm is biased.  We are giving special treatment to the last pick and this is skewing the distribution.  So, what if we reject the draw as soon as we find an element in the wrong place:</p>

<pre><code>fun draw3(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n).toSet()
    class BadPotException : RuntimeException()
    while (true) {
        val pot = players.toMutableList()
        Collections.shuffle(pot)
        try {
            val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
            players.forEach {
                if (pot[0] == it) {
                    throw BadPotException()
                }
                result.add(Pair(it, pot.removeAt(0)))
            }
            return result
        }
        catch (e: BadPotException) {
            // ok, try again
        }
    }
}    
</code></pre>

<p>We will be doing more work here, but the distribution looks better:</p>

<pre><code>[(1, 2), (2, 4), (3, 1), (4, 3)]=11221
[(1, 4), (2, 3), (3, 1), (4, 2)]=11203
[(1, 3), (2, 1), (3, 4), (4, 2)]=11176
[(1, 4), (2, 1), (3, 2), (4, 3)]=11151
[(1, 3), (2, 4), (3, 1), (4, 2)]=11092
[(1, 3), (2, 4), (3, 2), (4, 1)]=11087
[(1, 4), (2, 3), (3, 2), (4, 1)]=11042
[(1, 2), (2, 3), (3, 4), (4, 1)]=11022
[(1, 2), (2, 1), (3, 4), (4, 3)]=11006
</code></pre>

<h4 id="derangements">Derangements</h4>

<p>At this point let&rsquo;s forget the hat metaphor:</p>

<pre><code>fun draw4(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n).toSet()
    val permutation = players.toMutableList()
    do Collections.shuffle(permutation)
        while (players.any { it == permutation[it - 1] })
    return players.map { Pair(it, permutation[it - 1]) }
} 
</code></pre>

<p>We are generating permutations of the players and rejecting them if they are not &ldquo;derangements&rdquo; (<a href="https://en.wikipedia.org/wiki/Derangement">https://en.wikipedia.org/wiki/Derangement</a>).  There were 9 derangements of 4 players.  Let&rsquo;s see how many we get for 5, 6 and 7 players:</p>

<pre><code>for (i in 5..7) {
    val patterns = mutableSetOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()
    (1..100_000).forEach {
        val pattern = SecretSanta().draw4(i)
        patterns.add(pattern)
    }
    println(&quot;Found ${patterns.size} derangements for $i players&quot;)
}

Found 44 derangements for 5 players
Found 265 derangements for 6 players
Found 1854 derangements for 7 players
</code></pre>

<p>Of course, just doing it 100,000 times doesn&rsquo;t mean we hit all of the possible derangements.  To check:</p>

<pre><code>for (i in (4..11)) {
    val count = generatePermutations((0 until i).toList())
            .filter { perm -&gt; (0 until i).none { perm[it] == it } }.count()
    println(&quot;Found $count derangements of $i elements&quot;)
}

Found 9 derangements of 4 elements
Found 44 derangements of 5 elements
Found 265 derangements of 6 elements
Found 1854 derangements of 7 elements
Found 14833 derangements of 8 elements
Found 133496 derangements of 9 elements
Found 1334961 derangements of 10 elements
Found 14684570 derangements of 11 elements
</code></pre>

<p>I&rsquo;m using a library Steinhaus–Johnson–Trotter algorithm to generate permutations and it gets slow after 11 but we can see the sequence continuing at <a href="https://oeis.org/A000166">https://oeis.org/A000166</a>.</p>

<p>We have not been tracking how many times we had to shuffle.  We can assume it&rsquo;s not too many times since, so far, we were able to perform draws quite quickly.  But will we have to shuffle more as we have more players?  Counting the shuffles and timing gives:</p>

<pre><code>10 players took 29ms and performed 7 shuffles
100 players took 0ms and performed 1 shuffles
1000 players took 9ms and performed 5 shuffles
10000 players took 36ms and performed 3 shuffles
100000 players took 172ms and performed 4 shuffles
1000000 players took 1822ms and performed 2 shuffles
10000000 players took 158218ms and performed 6 shuffles
</code></pre>

<p>We don&rsquo;t have to shuffle more at all, but shuffling itself must take longer, as we would expect.  On the last one my laptop lost its mind.  So the lack of shuffling suggests that derangements remain fairly common even as the number of permutations goes through the roof (there are n! permutations of n elements).  It turns out (see <a href="https://en.wikipedia.org/wiki/Derangement">https://en.wikipedia.org/wiki/Derangement</a> again) that the ratio of permutations to derangements tends to 1/e as n goes to infinity.  So we don&rsquo;t need to worry about that.</p>

<h4 id="cycles">Cycles</h4>

<p>The first time I organised a Secret Santa game one player succeeded in figuring out the assignments through detective work and confessions.  We had 16 players that year.</p>

<pre><code>Tom -&gt; Alice -&gt; Ashley -&gt; Nora  
 |                          |
Eric &lt;- Laine &lt;- Elron &lt;- John


        Mark -&gt; Ambs -&gt; Andy 
          |               |  
        Laura &lt;- Cory &lt;- Indy


                Derek --&gt; Gerry 
                  `-----&lt;----'
</code></pre>

<p>Seeing this graph made me think about a few things:</p>

<ol>
<li>It&rsquo;s fun to look at the assignments as cyclic graphs</li>
<li>It&rsquo;s possible we could have had one big cycle</li>
<li>It&rsquo;s possible we could have had 8 pairs</li>
</ol>

<p>First let&rsquo;s look at this particular graph.  So how likely was the 3 component to happen?  To find the real answer we&rsquo;d have to look at all derangements of 16 elements and there are 7,697,064,251,745 of those.  Instead I sampled 10 million at random:</p>

<pre><code>      3 instances of 8 components (ratio 0.000000)
    554 instances of 7 components (ratio 0.000055)
  17683 instances of 6 components (ratio 0.001768)
 211913 instances of 5 components (ratio 0.021191)
1156218 instances of 4 components (ratio 0.115622)
1698725 instances of 1 components (ratio 0.169873)
3090215 instances of 3 components (ratio 0.309022)
3824689 instances of 2 components (ratio 0.382469)
</code></pre>

<p>So 3 components isn&rsquo;t very rare.  What about the particular pattern of a 2 node components, a 6 node and an 2 node?  From another sample of 10 million:</p>

<pre><code>      3 instances of [2, 2, 2, 2, 2, 2, 2, 2] (ratio 0.000000)
    145 instances of [2, 2, 2, 2, 2, 2, 4]    (ratio 0.000015)
    420 instances of [2, 2, 2, 2, 2, 3, 3]    (ratio 0.000042)
   1185 instances of [2, 2, 2, 2, 2, 6]       (ratio 0.000119)
   1755 instances of [2, 2, 3, 3, 3, 3]       (ratio 0.000176)
   2197 instances of [2, 2, 2, 2, 4, 4]       (ratio 0.000220)
   3584 instances of [3, 3, 3, 3, 4]          (ratio 0.000358)
   4445 instances of [4, 4, 4, 4]             (ratio 0.000445)
   4647 instances of [2, 2, 2, 2, 3, 5]       (ratio 0.000465)
   8069 instances of [2, 2, 2, 3, 3, 4]       (ratio 0.000807)
   8857 instances of [2, 2, 4, 4, 4]          (ratio 0.000886)
   8879 instances of [2, 2, 2, 2, 8]          (ratio 0.000888)
  11398 instances of [2, 2, 2, 5, 5]          (ratio 0.001140)
  16774 instances of [2, 3, 3, 3, 5]          (ratio 0.001677)
  23567 instances of [2, 2, 2, 4, 6]          (ratio 0.002357)
  23729 instances of [2, 3, 3, 4, 4]          (ratio 0.002373)
  23991 instances of [3, 3, 3, 7]             (ratio 0.002399)
  27059 instances of [2, 2, 2, 3, 7]          (ratio 0.002706)
  30141 instances of [3, 3, 5, 5]             (ratio 0.003014)
  31520 instances of [2, 2, 3, 3, 6]          (ratio 0.003152)
  47000 instances of [2, 2, 6, 6]             (ratio 0.004700)
  56214 instances of [3, 4, 4, 5]             (ratio 0.005621)
  56321 instances of [2, 2, 2, 10]            (ratio 0.005632)
  56515 instances of [2, 2, 3, 4, 5]          (ratio 0.005652)
  62915 instances of [3, 3, 4, 6]             (ratio 0.006292)
  68133 instances of [2, 4, 5, 5]             (ratio 0.006813)
  70954 instances of [2, 4, 4, 6]             (ratio 0.007095)
  90871 instances of [5, 5, 6]                (ratio 0.009087)
  94380 instances of [4, 6, 6]                (ratio 0.009438)
  94532 instances of [2, 3, 3, 8]             (ratio 0.009453)
  96845 instances of [2, 2, 5, 7]             (ratio 0.009685)
 106051 instances of [4, 4, 8]                (ratio 0.010605)
 106113 instances of [2, 2, 4, 8]             (ratio 0.010611)
 126166 instances of [2, 2, 3, 9]             (ratio 0.012617)
 138703 instances of [2, 7, 7]                (ratio 0.013870)
 150604 instances of [2, 3, 5, 6]             (ratio 0.015060)
 150766 instances of [3, 3, 10]               (ratio 0.015077)
 162452 instances of [2, 3, 4, 7]             (ratio 0.016245)
 194590 instances of [4, 5, 7]                (ratio 0.019459)
 212145 instances of [8, 8]                   (ratio 0.021215)
 215861 instances of [3, 6, 7]                (ratio 0.021586)
 227178 instances of [3, 5, 8]                (ratio 0.022718)
 251454 instances of [3, 4, 9]                (ratio 0.025145)
 282413 instances of [2, 6, 8]                (ratio 0.028241)
 282690 instances of [2, 2, 12]               (ratio 0.028269)
 301765 instances of [2, 5, 9]                (ratio 0.030177)
 340009 instances of [2, 4, 10]               (ratio 0.034001)
 411921 instances of [2, 3, 11]               (ratio 0.041192)
 431182 instances of [7, 9]                   (ratio 0.043118)
 453110 instances of [6, 10]                  (ratio 0.045311)
 494113 instances of [5, 11]                  (ratio 0.049411)
 566147 instances of [4, 12]                  (ratio 0.056615)
 696411 instances of [3, 13]                  (ratio 0.069641)
 971812 instances of [2, 14]                  (ratio 0.097181)
1699299 instances of [16]                     (ratio 0.169930)
</code></pre>

<p>It&rsquo;s one of the less rare ones, and happens around 3% of the time.</p>

</div>

    
<footer class='entry-footer-container'>
  <div class='entry-footer'>
  
  </div>
</footer>


  </article>
  
  
</main>

    <footer id='footer' class='footer-container'>
      <div class='footer'>
        <div class='social-menu-container'>
  <nav aria-label='Social Menu'>
    <ul class='social-menu'></ul>
  </nav>
</div>
        <div class='copyright'>
  <p>
  </p>
</div>

      </div>
    </footer>

  </div><script src='/assets/js/main.5871befd.js'></script></body>

</html>

