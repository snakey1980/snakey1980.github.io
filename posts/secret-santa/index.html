<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Names in a hat The first time I played Secret Santa we assigned givers/receivers like this:
 Players put their name in a hat Players take turn to pull names out. If you pull your own name, put it back and pull again.  So this is how I tried to implement it. Here we use plain integers as the players:
fun draw(players: Set&lt;Int&gt;) : List&lt;Pair&lt;Int, Int&gt;&gt; { if (players.'>

<meta property='og:title' content='Secret Santa • snakey1980&#39;s GitHub Pages'>
<meta property='og:description' content='Names in a hat The first time I played Secret Santa we assigned givers/receivers like this:
 Players put their name in a hat Players take turn to pull names out. If you pull your own name, put it back and pull again.  So this is how I tried to implement it. Here we use plain integers as the players:
fun draw(players: Set&lt;Int&gt;) : List&lt;Pair&lt;Int, Int&gt;&gt; { if (players.'>
<meta property='og:url' content='http://snakey1980.github.io/posts/secret-santa/'>
<meta property='og:site_name' content='snakey1980&#39;s GitHub Pages'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2017-11-13T19:49:44-05:00'/><meta property='article:modified_time' content='2017-11-13T19:49:44-05:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.30.2" />

  <title>Secret Santa • snakey1980&#39;s GitHub Pages</title>
  <link rel='canonical' href='http://snakey1980.github.io/posts/secret-santa/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Ubuntu:400,400i,700&subset=latin'>
<link rel='stylesheet' href='/assets/css/main.77da63e1.css'>
</head>


<body class='page type-posts'>
  <div class='site'>

    <a class='screen-reader' href='#main'>Skip to Content</a>

    <header id='header' class='header-container'>
      <div class='header site-header'>
        <nav id='main-menu' class='main-menu-container' aria-label='Main Menu'>
  <ul class='main-menu'>
  
  </ul>
</nav>

        <div class='header-info'>
          
          <p class='site-title title'>snakey1980&#39;s GitHub Pages</p>
          
          <p class='site-description subtitle'></p>
        </div>
      </div>
    </header>


<main id='main' class='main'>
  <article lang='en' class='entry'>
    <header class='header-container'>
  <div class='header entry-header'>
    <div class='header-info'>
      <h1 class='title'>Secret Santa</h1>
      

    </div>
    
<div class='meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader'>Posted on </span>
  <time class='date' datetime='2017-11-13T19:49:44-05:00'>2017, Nov 13</time>
</span>

  
  

</div>


  </div>
</header>

    
    

    <div class='entry-content'>
  

<h4 id="names-in-a-hat">Names in a hat</h4>

<p>The first time I played Secret Santa we assigned givers/receivers like this:</p>

<ol>
<li>Players put their name in a hat</li>
<li>Players take turn to pull names out.  If you pull your own name, put it back and pull again.</li>
</ol>

<p>So this is how I tried to implement it.  Here we use plain integers as the players:</p>

<pre><code>fun draw(players: Set&lt;Int&gt;) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (players.size &lt; 4) throw IllegalArgumentException()
    val pot = players.toMutableList()
    Collections.shuffle(pot)
    val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
    players.forEach {
        while (pot[0] == it) {
            Collections.shuffle(pot)
        }
        result.add(Pair(it, pot.removeAt(0)))
    }
    return result
}
</code></pre>

<p>On a first try it seems to work:</p>

<pre><code>println(SecretSanta().draw(setOf(1, 2, 3, 4)))
// printed [(1, 4), (2, 1), (3, 2), (4, 3)]
</code></pre>

<p>but try it a few times and, on some runs, it will never finish.  It&rsquo;s not hard to see why &ndash; it&rsquo;s possible that when number 4 comes to choose, it finds only itself in the pot and reshuffles uselessly forever.</p>

<p>This could happen in a real names-in-a-hat situation too.  When it does, there&rsquo;s nothing to be done but to put all the names back in and try again, so that&rsquo;s what I tried next:</p>

<pre><code>fun draw2(players: Set&lt;Int&gt;) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    class BadPotException : RuntimeException()
    if (players.size &lt; 4) throw IllegalArgumentException()
    while (true) {
        val pot = players.toMutableList()
        Collections.shuffle(pot)
        try {
            val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
            players.forEach {
                if (pot.size == 1 &amp;&amp; pot[0] == it) {
                    throw BadPotException()
                }
                while (pot[0] == it) {
                    Collections.shuffle(pot)
                }
                result.add(Pair(it, pot.removeAt(0)))
            }
            return result
        }
        catch (e: BadPotException) {
            // ok, try again
        }
    }
}
</code></pre>

<p>This always seems to stop, so we are doing slightly better:</p>

<pre><code>(1..100_000).forEach { SecretSanta().draw2(setOf(1, 2, 3, 4)) }
</code></pre>

<p>With 4 players, there aren&rsquo;t many valid assignments.  We can list out all the permutations and pick out the 9 valid ones:</p>

<pre><code>           PERMUTATION            VALID SECRET SANTA ASSIGNMENT?

[(1, 1), (2, 2), (3, 3), (4, 4)]              no
[(1, 1), (2, 2), (3, 4), (4, 3)]              no
[(1, 1), (2, 3), (3, 2), (4, 4)]              no
[(1, 1), (2, 3), (3, 4), (4, 2)]              no
[(1, 1), (2, 4), (3, 2), (4, 3)]              no
[(1, 1), (2, 4), (3, 3), (4, 2)]              no
[(1, 2), (2, 1), (3, 3), (4, 4)]              no
[(1, 2), (2, 1), (3, 4), (4, 3)]              yes
[(1, 2), (2, 3), (3, 1), (4, 4)]              no
[(1, 2), (2, 3), (3, 4), (4, 1)]              yes
[(1, 2), (2, 4), (3, 1), (4, 3)]              yes
[(1, 2), (2, 4), (3, 3), (4, 1)]              no
[(1, 3), (2, 1), (3, 2), (4, 4)]              no
[(1, 3), (2, 1), (3, 4), (4, 2)]              yes
[(1, 3), (2, 2), (3, 1), (4, 4)]              no
[(1, 3), (2, 2), (3, 4), (4, 1)]              no
[(1, 3), (2, 4), (3, 1), (4, 2)]              yes
[(1, 3), (2, 4), (3, 2), (4, 1)]              yes
[(1, 4), (2, 1), (3, 2), (4, 3)]              yes
[(1, 4), (2, 1), (3, 3), (4, 2)]              no
[(1, 4), (2, 2), (3, 1), (4, 3)]              no
[(1, 4), (2, 2), (3, 3), (4, 1)]              no
[(1, 4), (2, 3), (3, 1), (4, 2)]              yes
[(1, 4), (2, 3), (3, 2), (4, 1)]              yes
</code></pre>

<p>A good test would be to see if our procedure return each of the nine, and that it returns each one one ninth of the time:</p>

<pre><code>val patterns = mutableMapOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;, Int&gt;()
    (1..100_000).forEach {
        val pattern = SecretSanta().draw2(setOf(1, 2, 3, 4))
        patterns[pattern] = patterns.getOrDefault(pattern, 0) + 1
    }
    patterns.entries.sortedByDescending { it.value }.forEach { println(it) }
</code></pre>

<p>We run it 100,000 times and would expect each pattern to occur around 11111 times.  But:</p>

<pre><code>[(1, 4), (2, 1), (3, 2), (4, 3)]=19241
[(1, 2), (2, 4), (3, 1), (4, 3)]=13004
[(1, 2), (2, 1), (3, 4), (4, 3)]=12943
[(1, 3), (2, 4), (3, 2), (4, 1)]=9775
[(1, 4), (2, 3), (3, 1), (4, 2)]=9720
[(1, 4), (2, 3), (3, 2), (4, 1)]=9685
[(1, 3), (2, 4), (3, 1), (4, 2)]=9591
[(1, 3), (2, 1), (3, 4), (4, 2)]=9532
[(1, 2), (2, 3), (3, 4), (4, 1)]=6509
</code></pre>

<p>The algorithm is biased.  We are giving special treatment to the last pick and this is skewing everything.  What if we reject the draw as soon as we find an element in the wrong place:</p>

<pre><code>fun draw3(players: Set&lt;Int&gt;) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    class BadPotException : RuntimeException()
    if (players.size &lt; 4) throw IllegalArgumentException()
    while (true) {
        val pot = players.toMutableList()
        Collections.shuffle(pot)
        try {
            val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
            players.forEach {
                if (pot[0] == it) {
                    throw BadPotException()
                }
                result.add(Pair(it, pot.removeAt(0)))
            }
            return result
        }
        catch (e: BadPotException) {
            // ok, try again
        }
    }
}
</code></pre>

<p>We will be doing more work here, but the distribution looks better:</p>

<pre><code>[(1, 2), (2, 4), (3, 1), (4, 3)]=11221
[(1, 4), (2, 3), (3, 1), (4, 2)]=11203
[(1, 3), (2, 1), (3, 4), (4, 2)]=11176
[(1, 4), (2, 1), (3, 2), (4, 3)]=11151
[(1, 3), (2, 4), (3, 1), (4, 2)]=11092
[(1, 3), (2, 4), (3, 2), (4, 1)]=11087
[(1, 4), (2, 3), (3, 2), (4, 1)]=11042
[(1, 2), (2, 3), (3, 4), (4, 1)]=11022
[(1, 2), (2, 1), (3, 4), (4, 3)]=11006
</code></pre>

<p>At this point let&rsquo;s forget the hat metaphor and more honestly represent what we are doing:</p>

<pre><code>fun draw4(players: Set&lt;Int&gt;) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (players.size &lt; 4) throw IllegalArgumentException()
    val permutation = players.toMutableList()
    do Collections.shuffle(permutation)
        while (players.any { it == permutation[it - 1] })
    return players.map { Pair(it, permutation[it - 1]) }
}
</code></pre>

<p>We are generating permutations of the players and rejecting them if they are not &ldquo;derangements&rdquo;.  We found there were 9 derangements of 4 players.  Let&rsquo;s see how many we get for 5, 6 and 7 players:</p>

<pre><code>for (i in 5..7) {
    val patterns = mutableSetOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()
    (1..100_000).forEach {
        val pattern = SecretSanta().draw4((1..i).toSet())
        patterns.add(pattern)
    }
    println(&quot;Found ${patterns.size} derangements for $i players&quot;)
}

Found 44 derangements for 5 players
Found 265 derangements for 6 players
Found 1854 derangements for 7 players
</code></pre>

<p>This agrees with <a href="https://oeis.org/A000166">https://oeis.org/A000166</a> which describes this sequence.</p>

<p>We are not tracking how many times we had to shuffle.  We can assume it&rsquo;s not too many times since, so far, we were able to perform draws quite quickly.  But will it get a lot harder as we have more players?  Counting the shuffles and timing gives:</p>

<pre><code>10 players took 29ms and performed 7 shuffles
100 players took 0ms and performed 1 shuffles
1000 players took 9ms and performed 5 shuffles
10000 players took 36ms and performed 3 shuffles
100000 players took 172ms and performed 4 shuffles
1000000 players took 1822ms and performed 2 shuffles
10000000 players took 158218ms and performed 6 shuffles
</code></pre>

<p>It doesn&rsquo;t become harder to find derangements so we never need to shuffle many times but it does become harder to shuffle.  On the last one my laptop was thrashing.</p>

</div>

    
<footer class='entry-footer-container'>
  <div class='entry-footer'>
  
  </div>
</footer>


  </article>
  
  
</main>

    <footer id='footer' class='footer-container'>
      <div class='footer'>
        <div class='social-menu-container'>
  <nav aria-label='Social Menu'>
    <ul class='social-menu'></ul>
  </nav>
</div>
        <div class='copyright'>
  <p>
  </p>
</div>

      </div>
    </footer>

  </div><script src='/assets/js/main.5871befd.js'></script></body>

</html>

