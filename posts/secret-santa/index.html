<!DOCTYPE html>
<html lang='en'>

<head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Things I never knew I never knew about Secret Santa&hellip;
Names in a hat The first time I played Secret Santa we assigned givers and receivers like so:
 Put the names of all the players in a hat Take turns to shake the hat and pick a name out at random. If you pick your own name, put it back and pick again.  So when I decided to program it this is how I tried to do it.'>

<meta property='og:title' content='Secret Santa • snakey1980&#39;s GitHub Pages'>
<meta property='og:description' content='Things I never knew I never knew about Secret Santa&hellip;
Names in a hat The first time I played Secret Santa we assigned givers and receivers like so:
 Put the names of all the players in a hat Take turns to shake the hat and pick a name out at random. If you pick your own name, put it back and pick again.  So when I decided to program it this is how I tried to do it.'>
<meta property='og:url' content='http://snakey1980.github.io/posts/secret-santa/'>
<meta property='og:site_name' content='snakey1980&#39;s GitHub Pages'>
<meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2017-11-13T19:49:44-05:00'/><meta property='article:modified_time' content='2017-11-13T19:49:44-05:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.30.2" />

  <title>Secret Santa • snakey1980&#39;s GitHub Pages</title>
  <link rel='canonical' href='http://snakey1980.github.io/posts/secret-santa/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Ubuntu:400,400i,700&subset=latin'>
<link rel='stylesheet' href='/assets/css/main.77da63e1.css'>
</head>


<body class='page type-posts'>
  <div class='site'>

    <a class='screen-reader' href='#main'>Skip to Content</a>

    <header id='header' class='header-container'>
      <div class='header site-header'>
        <nav id='main-menu' class='main-menu-container' aria-label='Main Menu'>
  <ul class='main-menu'>
  
  </ul>
</nav>

        <div class='header-info'>
          
          <p class='site-title title'>snakey1980&#39;s GitHub Pages</p>
          
          <p class='site-description subtitle'></p>
        </div>
      </div>
    </header>


<main id='main' class='main'>
  <article lang='en' class='entry'>
    <header class='header-container'>
  <div class='header entry-header'>
    <div class='header-info'>
      <h1 class='title'>Secret Santa</h1>
      

    </div>
    
<div class='meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader'>Posted on </span>
  <time class='date' datetime='2017-11-13T19:49:44-05:00'>2017, Nov 13</time>
</span>

  
  

</div>


  </div>
</header>

    
    

    <div class='entry-content'>
  

<p>Things I never knew I never knew about Secret Santa&hellip;</p>

<h4 id="names-in-a-hat">Names in a hat</h4>

<p>The first time I played Secret Santa we assigned givers and receivers like so:</p>

<ol>
<li>Put the names of all the players in a hat</li>
<li>Take turns to shake the hat and pick a name out at random.  If you pick your own name, put it back and pick again.</li>
</ol>

<p>So when I decided to program it this is how I tried to do it.  Here we use integers as the players and they get paired up in giver, receiver pairs:</p>

<pre><code>fun draw(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n)
    val hat = players.toMutableList()
    Collections.shuffle(hat)
    val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
    players.forEach {
        while (hat[0] == it) {
            Collections.shuffle(hat)
        }
        result.add(Pair(it, hat.removeAt(0)))
    }
    return result
}
</code></pre>

<p>On a first try it seems to work:</p>

<pre><code>println(SecretSanta().draw(4))
// printed [(1, 4), (2, 1), (3, 2), (4, 3)]
</code></pre>

<p>but try it a few times and, on some runs, it will never finish.  It&rsquo;s not hard to see why &ndash; it&rsquo;s possible that when number 4 comes to choose, it finds only itself in the hat and reshuffles forever.</p>

<p>This could happen in a real names-in-a-hat situation too.  Has it ever happened to you?  When it does, there&rsquo;s nothing to be done but to put all the names back in and try again, so that&rsquo;s what I tried next:</p>

<pre><code>fun draw2(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n)
    class BadHatException : RuntimeException()
    while (true) {
        val hat = players.toMutableList()
        Collections.shuffle(hat)
        try {
            val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
            players.forEach {
                if (hat.size == 1 &amp;&amp; hat[0] == it) {
                    throw BadHatException()
                }
                while (hat[0] == it) {
                    Collections.shuffle(hat)
                }
                result.add(Pair(it, hat.removeAt(0)))
            }
            return result
        }
        catch (e: BadHatException) {
            // ok, try again
        }
    }
}
</code></pre>

<p>This always seems to stop, so we are doing slightly better:</p>

<pre><code>(1..100_000).forEach { SecretSanta().draw2(4) }
</code></pre>

<p>With 4 players, there aren&rsquo;t many valid assignments, just these 9:</p>

<pre><code>[(1, 2), (2, 1), (3, 4), (4, 3)]
[(1, 2), (2, 3), (3, 4), (4, 1)]
[(1, 2), (2, 4), (3, 1), (4, 3)]
[(1, 3), (2, 1), (3, 4), (4, 2)]
[(1, 3), (2, 4), (3, 1), (4, 2)]
[(1, 3), (2, 4), (3, 2), (4, 1)]
[(1, 4), (2, 1), (3, 2), (4, 3)]
[(1, 4), (2, 3), (3, 1), (4, 2)]
[(1, 4), (2, 3), (3, 2), (4, 1)]
</code></pre>

<p>A good test would be to see if our procedure returns each of the nine, and that it returns each one <sup>1</sup>&frasl;<sub>9</sub> of the time:</p>

<pre><code>val patterns = mutableMapOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;, Int&gt;()
(1..100_000).forEach {
    val pattern = SecretSanta().draw2(4)
    patterns[pattern] = patterns.getOrDefault(pattern, 0) + 1
}
patterns.entries.sortedByDescending { it.value }.forEach { println(it) }
</code></pre>

<p>We run it 100,000 times and would expect each pattern to occur around 11,111 times.  But:</p>

<pre><code>[(1, 4), (2, 1), (3, 2), (4, 3)]=19241
[(1, 2), (2, 4), (3, 1), (4, 3)]=13004
[(1, 2), (2, 1), (3, 4), (4, 3)]=12943
[(1, 3), (2, 4), (3, 2), (4, 1)]=9775
[(1, 4), (2, 3), (3, 1), (4, 2)]=9720
[(1, 4), (2, 3), (3, 2), (4, 1)]=9685
[(1, 3), (2, 4), (3, 1), (4, 2)]=9591
[(1, 3), (2, 1), (3, 4), (4, 2)]=9532
[(1, 2), (2, 3), (3, 4), (4, 1)]=6509
</code></pre>

<p>The algorithm is biased.  We are giving special treatment to the last pick and this is skewing the distribution.  So, what if we reject the draw as soon as we find an element in the wrong place:</p>

<pre><code>fun draw3(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n)
    class BadHatException : RuntimeException()
    while (true) {
        val hat = players.toMutableList()
        Collections.shuffle(hat)
        try {
            val result = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()
            players.forEach {
                if (hat[0] == it) {
                    throw BadHatException()
                }
                result.add(Pair(it, hat.removeAt(0)))
            }
            return result
        }
        catch (e: BadHatException) {
            // ok, try again
        }
    }
}    
</code></pre>

<p>We will be doing more work here, but the distribution looks better:</p>

<pre><code>[(1, 2), (2, 4), (3, 1), (4, 3)]=11221
[(1, 4), (2, 3), (3, 1), (4, 2)]=11203
[(1, 3), (2, 1), (3, 4), (4, 2)]=11176
[(1, 4), (2, 1), (3, 2), (4, 3)]=11151
[(1, 3), (2, 4), (3, 1), (4, 2)]=11092
[(1, 3), (2, 4), (3, 2), (4, 1)]=11087
[(1, 4), (2, 3), (3, 2), (4, 1)]=11042
[(1, 2), (2, 3), (3, 4), (4, 1)]=11022
[(1, 2), (2, 1), (3, 4), (4, 3)]=11006
</code></pre>

<p>You would never think to do it this way in a real names-in-a-hat situation but you&rsquo;d need to if you wanted to be fair.</p>

<h4 id="derangements">Derangements</h4>

<p>At this point let&rsquo;s forget the hat metaphor:</p>

<pre><code>fun draw4(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n)
    val permutation = players.toMutableList()
    do Collections.shuffle(permutation)
        while (players.any { it == permutation[it - 1] })
    return players.map { Pair(it, permutation[it - 1]) }
} 
</code></pre>

<p>We are generating permutations of the players and rejecting them if they are not <a href="https://en.wikipedia.org/wiki/Derangement">derangements</a>.  There were 9 derangements of 4 players.  Let&rsquo;s see how many we get for 5, 6 and 7 players:</p>

<pre><code>for (i in 5..7) {
    val patterns = mutableSetOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()
    (1..100_000).forEach {
        val pattern = SecretSanta().draw4(i)
        patterns.add(pattern)
    }
    println(&quot;Found ${patterns.size} derangements for $i players&quot;)
}

Found 44 derangements for 5 players
Found 265 derangements for 6 players
Found 1854 derangements for 7 players
</code></pre>

<p>Of course, just doing it 100,000 times doesn&rsquo;t mean we hit all of the possible derangements.  To check:</p>

<pre><code>for (i in (4..11)) {
    val count = generatePermutations((0 until i).toList())
            .filter { perm -&gt; (0 until i).none { perm[it] == it } }.count()
    println(&quot;Found $count derangements of $i elements&quot;)
}

Found 9 derangements of 4 elements
Found 44 derangements of 5 elements
Found 265 derangements of 6 elements
Found 1854 derangements of 7 elements
Found 14833 derangements of 8 elements
Found 133496 derangements of 9 elements
Found 1334961 derangements of 10 elements
Found 14684570 derangements of 11 elements
</code></pre>

<p>I&rsquo;m using a library Steinhaus–Johnson–Trotter algorithm to generate permutations and it gets slow after 11 but we can see the sequence continuing in the <a href="https://oeis.org/A000166">OEIS article</a>.</p>

<p>We have not been tracking how many times we had to shuffle.  We can assume it&rsquo;s not too many times since, so far, we were able to perform draws quite quickly.  But will we have to shuffle more as we have more players?  Counting the shuffles and timing gives:</p>

<pre><code>      10 players took     29ms and performed 7 shuffles
     100 players took      0ms and performed 1 shuffles
    1000 players took      9ms and performed 5 shuffles
   10000 players took     36ms and performed 3 shuffles
  100000 players took    172ms and performed 4 shuffles
 1000000 players took   1822ms and performed 2 shuffles
10000000 players took 158218ms and performed 6 shuffles
</code></pre>

<p>We don&rsquo;t have to shuffle more, but shuffling itself takes longer as we add players.  On the last one my laptop lost its mind.  So the lack of shuffling suggests that derangements remain fairly common even as the number of permutations goes through the roof (there are n! permutations of n elements).  <a href="hthttps://en.wikipedia.org/wiki/Derangement#Limit_of_ratio_of_derangement_to_permutation_as_n_approaches_.E2.88.9E">It turns out</a> that the ratio of permutations to derangements tends to 1/e as n approaches infinity.  So we don&rsquo;t need to worry about that.</p>

<h4 id="cycles">Cycles</h4>

<p>The first time I organised a Secret Santa game one player succeeded in figuring out the assignments through detective work and confessions.  We had 16 players that year.</p>

<pre><code>Tom -&gt; Alice -&gt; Ashley -&gt; Nora  
 |                          |
Eric &lt;- Laine &lt;- Elron &lt;- John


        Mark -&gt; Ambs -&gt; Andy 
          |               |  
        Laura &lt;- Cory &lt;- Indy


                Derek --&gt; Gerry 
                  `-----&lt;----'
</code></pre>

<p>Seeing this graph made me think about a few things:</p>

<ol>
<li>It&rsquo;s fun to look at the assignments as cyclic graphs</li>
<li>It&rsquo;s possible we could have had one big cycle</li>
<li>It&rsquo;s possible we could have had 8 pairs</li>
</ol>

<p>First let&rsquo;s look at this particular graph.  How likely was it that we would end up with 3 components?  To find the real answer we&rsquo;d have to look at all derangements of 16 elements and there are 7,697,064,251,745 of those.  Instead I sampled 10 million at random:</p>

<pre><code>      3 instances of 8 components (ratio 0.000000)
    554 instances of 7 components (ratio 0.000055)
  17683 instances of 6 components (ratio 0.001768)
 211913 instances of 5 components (ratio 0.021191)
1156218 instances of 4 components (ratio 0.115622)
1698725 instances of 1 components (ratio 0.169873)
3090215 instances of 3 components (ratio 0.309022)
3824689 instances of 2 components (ratio 0.382469)
</code></pre>

<p>So 3 components is common.  The pairs on the other hand will hardly ever happen which is good as that would be a weird game.  What about the particular pattern of a 2 node components, a 6 node and an 8 node?  From a different sample of 10 million:</p>

<pre><code>      3 instances of [2, 2, 2, 2, 2, 2, 2, 2] (ratio 0.000000)
    145 instances of [2, 2, 2, 2, 2, 2, 4]    (ratio 0.000015)
    420 instances of [2, 2, 2, 2, 2, 3, 3]    (ratio 0.000042)
   1185 instances of [2, 2, 2, 2, 2, 6]       (ratio 0.000119)
   1755 instances of [2, 2, 3, 3, 3, 3]       (ratio 0.000176)
   2197 instances of [2, 2, 2, 2, 4, 4]       (ratio 0.000220)
   3584 instances of [3, 3, 3, 3, 4]          (ratio 0.000358)
   4445 instances of [4, 4, 4, 4]             (ratio 0.000445)
   4647 instances of [2, 2, 2, 2, 3, 5]       (ratio 0.000465)
   8069 instances of [2, 2, 2, 3, 3, 4]       (ratio 0.000807)
   8857 instances of [2, 2, 4, 4, 4]          (ratio 0.000886)
   8879 instances of [2, 2, 2, 2, 8]          (ratio 0.000888)
  11398 instances of [2, 2, 2, 5, 5]          (ratio 0.001140)
  16774 instances of [2, 3, 3, 3, 5]          (ratio 0.001677)
  23567 instances of [2, 2, 2, 4, 6]          (ratio 0.002357)
  23729 instances of [2, 3, 3, 4, 4]          (ratio 0.002373)
  23991 instances of [3, 3, 3, 7]             (ratio 0.002399)
  27059 instances of [2, 2, 2, 3, 7]          (ratio 0.002706)
  30141 instances of [3, 3, 5, 5]             (ratio 0.003014)
  31520 instances of [2, 2, 3, 3, 6]          (ratio 0.003152)
  47000 instances of [2, 2, 6, 6]             (ratio 0.004700)
  56214 instances of [3, 4, 4, 5]             (ratio 0.005621)
  56321 instances of [2, 2, 2, 10]            (ratio 0.005632)
  56515 instances of [2, 2, 3, 4, 5]          (ratio 0.005652)
  62915 instances of [3, 3, 4, 6]             (ratio 0.006292)
  68133 instances of [2, 4, 5, 5]             (ratio 0.006813)
  70954 instances of [2, 4, 4, 6]             (ratio 0.007095)
  90871 instances of [5, 5, 6]                (ratio 0.009087)
  94380 instances of [4, 6, 6]                (ratio 0.009438)
  94532 instances of [2, 3, 3, 8]             (ratio 0.009453)
  96845 instances of [2, 2, 5, 7]             (ratio 0.009685)
 106051 instances of [4, 4, 8]                (ratio 0.010605)
 106113 instances of [2, 2, 4, 8]             (ratio 0.010611)
 126166 instances of [2, 2, 3, 9]             (ratio 0.012617)
 138703 instances of [2, 7, 7]                (ratio 0.013870)
 150604 instances of [2, 3, 5, 6]             (ratio 0.015060)
 150766 instances of [3, 3, 10]               (ratio 0.015077)
 162452 instances of [2, 3, 4, 7]             (ratio 0.016245)
 194590 instances of [4, 5, 7]                (ratio 0.019459)
 212145 instances of [8, 8]                   (ratio 0.021215)
 215861 instances of [3, 6, 7]                (ratio 0.021586)
 227178 instances of [3, 5, 8]                (ratio 0.022718)
 251454 instances of [3, 4, 9]                (ratio 0.025145)
 282413 instances of [2, 6, 8]                (ratio 0.028241)
 282690 instances of [2, 2, 12]               (ratio 0.028269)
 301765 instances of [2, 5, 9]                (ratio 0.030177)
 340009 instances of [2, 4, 10]               (ratio 0.034001)
 411921 instances of [2, 3, 11]               (ratio 0.041192)
 431182 instances of [7, 9]                   (ratio 0.043118)
 453110 instances of [6, 10]                  (ratio 0.045311)
 494113 instances of [5, 11]                  (ratio 0.049411)
 566147 instances of [4, 12]                  (ratio 0.056615)
 696411 instances of [3, 13]                  (ratio 0.069641)
 971812 instances of [2, 14]                  (ratio 0.097181)
1699299 instances of [16]                     (ratio 0.169930)
</code></pre>

<p>It&rsquo;s one of the less rare ones, and happens around 3% of the time.  For fun let&rsquo;s try and work out the probability of hitting the complete single cycle of 16 to see if it matches our experience sampling.  To make the complete cycle, any element can be &ldquo;first&rdquo; so we can say there is one way of picking it.  Then the first element can pair with any other but itself, so there are 15 ways of doing that.  Then the next just has to avoid the first and itself, so there are 14 ways of doing that.  The next has 13 then 12 then 11 all the way to the last element which can only match to the first.</p>

<pre><code>1 * 15 * 14 * 13 * 12 * 11 * 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1 
    = 1307674368000
</code></pre>

<p>So 1,307,674,368,000 ways to make the single cycle.  Divided by the total number of possible derangements:</p>

<pre><code>1307674368000 / 7697064251745 =~ 0.169893
</code></pre>

<p>Close enough.</p>

<h4 id="back-to-the-hat">Back to the hat</h4>

<p>Back in the real world, we still have a problem in that the hat method has become annoying to implement, what with the high probability of telling people to restart multiple times.  There&rsquo;s a real world method described <a href="https://www.youtube.com/watch?v=GhnCj7Fvqt0">in this video</a> which can come up with a valid assignment in one pass.  The idea is you shuffle once and then each participant is assigned to its neighbour in the shuffle with the last in line looping around to be assigned to the first.  The video explains how to make this work with real people and paper.  In code it looks like:</p>

<pre><code>fun draw5(n: Int) : List&lt;Pair&lt;Int, Int&gt;&gt; {
    if (n &lt; 4) throw IllegalArgumentException()
    val players = (1..n)
    val permutation = players.toMutableList()
    return (0 until n).map { 
        Pair(permutation[it], permutation[(it + 1) % n])
    }
}
</code></pre>

<p>It&rsquo;s guaranteed to create a derangement and it&rsquo;s uniformly random over its possibilities.  A problem is that the possibilities themselves are restricted to complete cycles, meaning that we would be missing most derangements.  This might not matter if everyone is getting bubble bath and no one cares to guess who got what, but it somewhat spoils the detective work part.  On the other hand, a cycle is quite pleasing.  I did not adopt this method for my program.</p>

<h4 id="smarter-shuffling">Smarter shuffling</h4>

<p>So far I didn&rsquo;t worry about shuffling, I just used a library shuffle.  What if I write my own shuffle and adapt it to avoid non-derangements?  Then I could avoid ever reshuffling.  The shuffle I was using, java.util.Collections.shuffle, does something like this:</p>

<pre><code>fun shuffle(list: MutableList&lt;Int&gt;, random: Random) {
    fun swap(list: MutableList&lt;Int&gt;, i: Int, j: Int) {
        list.set(i, list.set(j, list[i]))
    }
    for (i in list.size downTo 2) {
        swap(list, i - 1, random.nextInt(i))
    }
}    
</code></pre>

<p>This is a modern Fisher-Yates shuffle.  My attempts to adapt it didn&rsquo;t end well and it seems this is a <a href="https://stackoverflow.com/questions/7279895/shuffle-list-ensuring-that-no-item-remains-in-same-position">tricky problem</a>.</p>

<p>My Secret Santa program is <a href="https://github.com/snakey1980/secretsanta">here</a>.</p>

</div>

    
<footer class='entry-footer-container'>
  <div class='entry-footer'>
  
  </div>
</footer>


  </article>
  
  
</main>

    <footer id='footer' class='footer-container'>
      <div class='footer'>
        <div class='social-menu-container'>
  <nav aria-label='Social Menu'>
    <ul class='social-menu'></ul>
  </nav>
</div>
        <div class='copyright'>
  <p>
  </p>
</div>

      </div>
    </footer>

  </div><script src='/assets/js/main.5871befd.js'></script></body>

</html>

